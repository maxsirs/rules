# ESP32 IoT开发教程 - Day标准编写规范 (rules.md)

---

## 📋 文档结构模板

```markdown
# 第N天任务：[主题名称]

---

## 📝 任务概述

### 核心目标
[一句话说明今天要学什么]

### 学习重点
- 重点1
- 重点2
- 重点3

---

## 🎯 任务布置

### 基础任务（必做）
**任务1：[任务名称]**
- 要求：[具体要求]
- 输出：[预期结果]
- 检验标准：[如何验证完成]

**任务2：[任务名称]**
- 要求：
- 输出：
- 检验标准：

### 进阶任务（选做）
**扩展1：[扩展功能]**
- 描述：[功能说明]
- 难度：⭐⭐⭐
- 提示：[实现思路]

**扩展2：[扩展功能]**
- 描述：
- 难度：
- 提示：

### 综合项目（整合）
**项目名称：[项目标题]**

功能需求：
- [ ] 功能1
- [ ] 功能2
- [ ] 功能3

技术栈：
- 硬件：[硬件列表]
- 软件：[软件模块]

---

## 💡 实现思路（伪代码）

### 整体流程
\```
步骤1：初始化系统
├─ 配置硬件引脚
├─ 初始化外设
└─ 启动任务

步骤2：主循环逻辑
├─ 读取输入
├─ 处理数据
└─ 输出结果

步骤3：异常处理
├─ 检测错误
└─ 恢复机制
\```

### 核心逻辑伪代码

\```c
// 功能模块1
function module_1() {
    // 步骤1：准备
    初始化变量
    配置参数
    
    // 步骤2：执行
    while (条件) {
        读取数据
        if (满足条件) {
            执行动作
        }
    }
    
    // 步骤3：清理
    释放资源
}

// 功能模块2
function module_2() {
    ...
}
\```

### 状态机流程（如适用）
\```
状态A ──[事件1]──> 状态B
状态B ──[事件2]──> 状态C
状态C ──[事件3]──> 状态A
\```

---

## 🔧 关键API说明

### API分类

#### 1. 初始化相关
\```c
// API名称：gpio_config
// 功能：配置GPIO引脚
// 参数：
//   - pin: 引脚号 (GPIO_NUM_XX)
//   - mode: 模式 (INPUT/OUTPUT/INPUT_PULLUP)
// 返回值：ESP_OK 成功，ESP_FAIL 失败
// 使用场景：设置LED、按钮等GPIO

esp_err_t gpio_config(const gpio_config_t *config);

// 参数结构体
typedef struct {
    uint64_t pin_bit_mask;      // 引脚位掩码
    gpio_mode_t mode;           // 输入/输出模式
    gpio_pullup_t pull_up_en;   // 上拉使能
    gpio_pulldown_t pull_down_en; // 下拉使能
    gpio_int_type_t intr_type;  // 中断类型
} gpio_config_t;

// 使用示例
gpio_config_t io_conf = {
    .pin_bit_mask = (1ULL << GPIO_NUM_2),
    .mode = GPIO_MODE_OUTPUT,
};
gpio_config(&io_conf);
\```

#### 2. 操作相关
\```c
// API名称：gpio_set_level
// 功能：设置GPIO电平
// 参数：
//   - gpio_num: 引脚号
//   - level: 电平 (0=低, 1=高)
// 返回值：ESP_OK
// 注意事项：引脚必须先配置为输出模式

esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level);

// 使用示例
gpio_set_level(GPIO_NUM_2, 1);  // 点亮LED
\```

#### 3. 查询相关
\```c
// API名称：gpio_get_level
// 功能：读取GPIO电平
// 参数：gpio_num - 引脚号
// 返回值：0或1

int gpio_get_level(gpio_num_t gpio_num);
\```

### API速查表

| API名称 | 功能 | 参数 | 返回值 | 常见用途 |
|---------|------|------|--------|----------|
| `api_1` | 功能说明 | (参数类型) | 返回类型 | 使用场景 |
| `api_2` | 功能说明 | (参数类型) | 返回类型 | 使用场景 |

### 常见宏定义

\```c
#define GPIO_OUTPUT_PIN    GPIO_NUM_2   // LED引脚
#define GPIO_INPUT_PIN     GPIO_NUM_0   // 按钮引脚

#define DELAY_MS           1000          // 延时1秒
#define BUFFER_SIZE        256           // 缓冲区大小
\```

---

## ⚠️ 重点难点解析

### 难点1：[难点名称]

**问题描述：**
[详细说明这个难点是什么，为什么难]

**原理解释：**
\```
[用图示或文字解释底层原理]

例如：
时序要求：
    ┌─┐     ┌─┐     ┌─┐
────┘ └─────┘ └─────┘ └────
    ↑       ↑       ↑
  起始    数据位   停止
  
  起始信号：拉低 > 18ms
  数据位：  高电平持续时间决定0/1
  停止信号：拉高
\```

**解决方案：**
\```c
// 方法1：使用延时精确控制
void send_start_signal() {
    gpio_set_level(PIN, 0);
    delay_ms(20);  // 必须 > 18ms
    gpio_set_level(PIN, 1);
}

// 方法2：使用硬件定时器（更精确）
void timer_callback() {
    // 在中断中切换电平
}
\```

**注意事项：**
- ⚠️ 注意点1
- ⚠️ 注意点2
- 💡 优化建议

### 难点2：[难点名称]

**问题描述：**
...

**原理解释：**
...

**解决方案：**
...

### 常见错误

**错误1：[错误现象]**
\```
症状：编译报错/运行异常
原因：[根本原因]
解决：[修正方法]
\```

**错误2：[错误现象]**
\```
症状：
原因：
解决：
\```

---

## 💻 代码实现

### 文件结构

\```
project_name/
├── main/
│   ├── main.c              # 主程序
│   ├── module_1.c          # 功能模块1
│   ├── module_1.h
│   ├── module_2.c          # 功能模块2
│   ├── module_2.h
│   └── CMakeLists.txt
├── CMakeLists.txt
└── sdkconfig
\```

### 代码实现1：模块名称

**功能说明：**
[这个模块做什么]

**代码：**
\```c
/*
 * 模块名称
 * 功能：[功能描述]
 * 作者：[可选]
 * 日期：DayN
 */

#include "header.h"

// ============ 宏定义 ============
#define CONFIG_VALUE  100

// ============ 全局变量 ============
static int g_counter = 0;

// ============ 函数实现 ============

/**
 * @brief 函数功能说明
 * @param param1 参数1说明
 * @param param2 参数2说明
 * @return 返回值说明
 * 
 * 使用示例：
 *   int result = function_name(10, 20);
 */
int function_name(int param1, int param2) {
    // 步骤1：参数检查
    if (param1 < 0 || param2 < 0) {
        return -1;  // 参数错误
    }
    
    // 步骤2：核心逻辑
    int result = param1 + param2;
    
    // 步骤3：记录日志（可选）
    ESP_LOGI(TAG, "计算结果: %d", result);
    
    return result;
}

// ============ 主函数 ============
void app_main(void) {
    // 1. 初始化
    ESP_LOGI(TAG, "系统启动...");
    
    // 2. 配置硬件
    // [配置代码]
    
    // 3. 启动功能
    function_name(10, 20);
    
    // 4. 主循环
    while (1) {
        // [循环代码]
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
\```

**代码解释：**

关键代码块解析：
\```c
// 这段代码的作用是 XXX
if (param1 < 0 || param2 < 0) {
    return -1;
}

// 为什么这样写？
// 1. 防止负数输入导致错误
// 2. 提前返回，避免后续计算
// 3. 返回-1作为错误标志
\```

流程说明：
\```
初始化 → 参数检查 → 核心计算 → 返回结果
  ↓          ↓           ↓          ↓
 成功      参数合法     计算完成    成功
          ↓
       失败返回-1
\```

### 代码实现2：模块名称

**功能说明：**
...

**代码：**
\```c
...
\```

**代码解释：**
...

---

## 🧪 测试验证

### 测试1：基础功能测试

**测试目的：**
验证[功能]是否正常工作

**测试步骤：**
1. 编译并烧录程序
2. 打开串口监视器（115200波特率）
3. 观察输出

**预期结果：**
\```
I (xxx) TAG: 系统启动...
I (xxx) TAG: GPIO初始化完成
I (xxx) TAG: LED闪烁中...
\```

**实际结果：**
- [ ] 编译通过
- [ ] 烧录成功
- [ ] 串口输出正确
- [ ] 功能正常

### 测试2：进阶功能测试

**测试目的：**
...

**测试步骤：**
...

**预期结果：**
...

### 故障排查

| 问题现象 | 可能原因 | 解决方法 |
|----------|----------|----------|
| LED不亮 | 引脚配置错误 | 检查GPIO_NUM |
| 编译报错 | 缺少头文件 | 添加 #include |
| 无串口输出 | 波特率不对 | 改为115200 |

---

## 📊 性能优化（可选）

### 优化点1：减少延时

**优化前：**
\```c
while (1) {
    do_work();
    delay(1000);  // 阻塞1秒
}
\```

**优化后：**
\```c
uint32_t last_time = 0;
while (1) {
    if (millis() - last_time >= 1000) {
        last_time = millis();
        do_work();
    }
    // 可以做其他事情
}
\```

**优化效果：**
- CPU利用率提升
- 响应速度提升

### 优化点2：内存优化

...

---

## 📚 扩展阅读

### 相关文档
- [ESP-IDF官方文档](https://docs.espressif.com/)
- [FreeRTOS文档](https://www.freertos.org/)

### 进阶主题
- 主题1：[深入理解XXX原理]
- 主题2：[XXX的高级应用]

### 参考项目
- GitHub项目1：[项目链接]
- GitHub项目2：[项目链接]

---

## ✅ 完成检查清单

- [ ] 理解了核心概念
- [ ] 完成了基础任务
- [ ] 代码能正常运行
- [ ] 通过了测试验证
- [ ] 尝试了进阶任务（选做）
- [ ] 代码已提交到Git（推荐）

---

## 🎯 下一步

### 明天预告（DayN+1）
明天将学习：[下一个主题]
- 内容1
- 内容2
- 内容3

### 知识衔接
今天学的XXX将在以下场景用到：
- 场景1
- 场景2

---

## 📝 学习笔记（学员填写）

### 今日收获
- 

### 遇到的问题
- 

### 解决方法
- 

### 心得体会
- 

---

*编写日期：20XX-XX-XX*
*适用版本：ESP-IDF v5.x*
*预计学习时间：X小时*
```

---

## 📋 模板使用说明

### 1. 必需部分（每个Day都要有）
- ✅ 任务概述
- ✅ 任务布置（基础+进阶）
- ✅ 实现思路（伪代码）
- ✅ 关键API
- ✅ 重点难点
- ✅ 代码实现

### 2. 可选部分（根据内容决定）
- ⭕ 性能优化（复杂项目需要）
- ⭕ 扩展阅读（深入学习）
- ⭕ 故障排查（常见问题多时添加）

### 3. 编写原则

#### 任务布置
- 基础任务：90%学员能完成
- 进阶任务：挑战性，30-50%学员完成
- 综合项目：整合多个知识点

#### 伪代码
- 先写流程图
- 再写伪代码
- 最后才是真实代码

#### 关键API
- 每个API必须包含：
  - 功能说明
  - 参数说明
  - 返回值
  - 使用示例
  - 注意事项

#### 重点难点
- 不超过3个难点
- 每个难点包含：
  - 问题描述
  - 原理解释
  - 解决方案
  - 注意事项

#### 代码实现
- 代码要简洁（核心功能）
- 注释要充分（解释为什么）
- 分段解释（关键代码块）
- 流程图辅助

### 4. 格式规范

#### 标题层级
\```
# 一级标题（Day标题）
## 二级标题（大章节）
### 三级标题（小章节）
#### 四级标题（具体内容）
\```

#### 代码块
- C代码：\```c
- Python：\```python
- Bash：\```bash
- 伪代码：\```

#### 强调标记
- ✅ 完成/正确
- ❌ 错误/不要
- ⚠️ 注意/警告
- 💡 提示/技巧
- ⭐ 重点/推荐
- 🎯 目标
- 💻 代码
- 📊 数据/图表

#### 列表
- 无序列表：用于并列项
- 有序列表：用于步骤
- 任务列表：- [ ] 用于检查项

### 5. 示例文件命名

\```
DayXX_[主题拼音].md

例如：
Day01_GPIO控制.md
Day02_ADC采集.md
Day03_FreeRTOS多任务.md
\```

---

## 🔍 质量检查清单

编写完成后，检查：

- [ ] 任务目标清晰明确
- [ ] 伪代码逻辑完整
- [ ] API说明准确详细
- [ ] 难点解释通俗易懂
- [ ] 代码能运行且有注释
- [ ] 测试步骤可操作
- [ ] 没有拼写错误
- [ ] 格式统一规范
- [ ] 图表清晰易懂
- [ ] 链接都能访问

---

## 📌 快速开始

### 创建新Day教程的步骤：

1. **复制模板**
   \```bash
   cp template.md Day25_新主题.md
   \```

2. **填写内容**
   - 先写任务目标
   - 再写伪代码
   - 列出API
   - 标注难点
   - 最后写代码

3. **自测**
   - 代码亲自运行一遍
   - 检查所有API是否正确
   - 确认难点解释清楚

4. **发布**
   - 提交到Git
   - 标注版本号
   - 添加更新日志

---

**最后提醒：好的教程 = 清晰的目标 + 简洁的代码 + 充分的解释**

*模板版本：v1.0*
*最后更新：2024*
